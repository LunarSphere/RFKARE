import ee
import geopy
from geopy.geocoders import Nominatim
from PIL import Image
import requests
from io import BytesIO
import math
import os
import numpy as np
import cv2

# ee.Authenticate()
# ee.Initialize(project='gthack25')
# print(ee.String('Hello from the Earth Engine servers!').getInfo())

def get_city_coordinates(city_name):
    # INPUTS: CITY NAME
    # OUTPUT: LAT AND LONG
    geolocator = Nominatim(user_agent="city_locator")
    location = geolocator.geocode(city_name)
    return location.latitude, location.longitude

# Function to get satellite image of a specific region using USDA/NAIP/DOQQ dataset
#.003625  = .25
def retrieve_naip_image(lat, long, date2, deltalr=0.0058, deltaud=0.0058, date1='2018-01-01'):
    """
    INPUTS: 
        LATITUDE
        LONGITUDE
        DATE2 - END DATE
        DATE1 - START DATE
        DELTALR - HALFWIDTH OF REGION LEFT TO RIGHT IN DEGREES (STRETCH THESE SO THE RADIUS IS A .5 MILE OR A MILE)
        DELTAUD - HALFWIDTH OF REGION TOP TO BOTTOM IN DEGREES
    OUTPUTS: IMAGE DATA
    """
    #CREATE A BOUNDING BOX FOR IMAGE (WOULD PROBABLY MESS WITH THIS TO ENFORCE A SHAPE)
    region = ee.Geometry.BBox(long - deltalr, lat - deltaud, long + deltalr, lat + deltaud)
    #SLICE IMAGE CLOSEST OT DATE 1 AND AND WITHIN SHAPE OF BOUNDING BOX
    dataset = ee.ImageCollection('USDA/NAIP/DOQQ') \
        .filter(ee.Filter.date(date1, date2)) \
        .filter(ee.Filter.bounds(region))
    return dataset

def save_image_from_url(url, filename):
    #SAVE IMAGE DATA TO PNG
    response = requests.get(url)
    if response.status_code == 200:
        image = Image.open(BytesIO(response.content))
        image.save(filename)
        # print(f"Satellite image saved as {filename}")
    else:
        print("Error fetching the satellite image.")

def capture_gee_images(city_lat, city_lon, date1='2018-01-01', date2='2025-02-22', 
                        deltalr=0.0145, deltaud=0.0145, miles_range=10):
    """
    Captures a grid of high quality satellite images from the provided Google Earth dataset.
    This uses the USDA/NAIP/DOQQ dataset available in Earth Engine.

    The grid is generated by using the provided deltalr and deltaud as half-widths (in degrees)
    for each image's bounding box, and covers a 15-mile radius around the city center.

    Each image is exported as a 1024x1024 PNG and saved in the "data" folder with filenames reflecting 
    their grid position.

    INPUTS:
      city_lat, city_lon   - Center coordinates of the city.
      date1                - Start date for filtering the image collection.
      date2                - End date for filtering the image collection.
      deltalr              - Half-width in longitude degrees for each image.
      deltaud              - Half-height in latitude degrees for each image.
      miles_range          - Radius in miles to cover around the city center.
    """
    # Create data directory if it does not exist
    data_dir = "data"
    os.makedirs(data_dir, exist_ok=True)
    
    # Conversion: 1 degree latitude is approximately 69 miles.
    half_extent_lat = miles_range / 69.0
    # Longitude degrees vary with latitude.
    half_extent_lon = miles_range / (69.0 * math.cos(math.radians(city_lat)))
    
    # Number of images needed in latitude and longitude directions.
    # Each image covers 2*deltaud degrees in latitude and 2*deltalr degrees in longitude.
    num_rows = math.ceil((2 * half_extent_lat) / (2 * deltaud))
    num_cols = math.ceil((2 * half_extent_lon) / (2 * deltalr))
    
    # Calculate starting coordinates (bottom-left of the grid)
    start_lat = city_lat - half_extent_lat
    start_lon = city_lon - half_extent_lon
    
    print(f"Capturing a grid of {num_rows} rows x {num_cols} columns of images using the Google Earth dataset...")
    
    for row in range(num_rows):
        for col in range(num_cols):
            if (np.sqrt((row - (num_rows/2))**2  + (col - (num_cols/2))**2) <= miles_range ):
                # Compute the center coordinate for the current grid cell.
                cell_center_lat = start_lat + (row * 2 * deltaud) + deltaud
                cell_center_lon = start_lon + (col * 2 * deltalr) + deltalr
                
                # Define the region for the image as a bounding box around the cell center.
                region = ee.Geometry.BBox(cell_center_lon - deltalr, cell_center_lat - deltaud,
                                          cell_center_lon + deltalr, cell_center_lat + deltaud)
                
                # Retrieve the image collection for the cell area using the provided dataset function.
                dataset = retrieve_naip_image(cell_center_lat, cell_center_lon, date2, deltalr, deltaud, date1)
                # Choose the first available image from the collection.
                image = dataset.first()
                
                # Select only the first three bands (typically representing RGB) to avoid encoding issues.
                image = image.select([0, 1, 2])
                
                # Set thumbnail parameters for a 1024x1024 image in PNG format.
                thumb_params = {
                    'region': region, 
                    'dimensions': '1024x1024', 
                    'format': 'png'
                }
                try:
                    image_url = image.getThumbURL(thumb_params)
                except Exception as e:
                    print(f"Error generating thumbnail URL for cell at row {row}, col {col}: {e}")
                    continue 
                    
                
                # Generate a filename based on grid row and column.
                filename = os.path.join(data_dir, f"gee_image_row{row}_col{col}.png")
                
                #print(f"Fetching image at lat: {cell_center_lat:.6f}, lon: {cell_center_lon:.6f}")
                save_image_from_url(image_url, filename)
            else:
                filename = os.path.join(data_dir, f"gee_image_row{row}_col{col}.png")
                image = np.zeros((1024, 1024), dtype=np.uint8)
                cv2.imwrite(filename, image)
                